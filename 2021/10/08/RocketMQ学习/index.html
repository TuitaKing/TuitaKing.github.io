<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="消息队列在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。  来自wiki。">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ学习">
<meta property="og:url" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Keanu Lee&#39;s Blog">
<meta property="og:description" content="消息队列在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。  来自wiki。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_architecture_1.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_architecture_2.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_1.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_datafile.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_2.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_3.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_4.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_5.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_6.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_7.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_8.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_9.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_10.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_11.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_12.png">
<meta property="og:image" content="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_13.png">
<meta property="og:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_save_message_1.png">
<meta property="article:published_time" content="2021-10-08T02:02:30.000Z">
<meta property="article:modified_time" content="2021-10-14T11:23:50.853Z">
<meta property="article:author" content="Keanu Lee">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_architecture_1.png">

<link rel="canonical" href="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>RocketMQ学习 | Keanu Lee's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Keanu Lee's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Keanu Lee">
      <meta itemprop="description" content="千里之行，始于足下">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keanu Lee's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RocketMQ学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-08 10:02:30" itemprop="dateCreated datePublished" datetime="2021-10-08T10:02:30+08:00">2021-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-14 19:23:50" itemprop="dateModified" datetime="2021-10-14T19:23:50+08:00">2021-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>消息队列</strong>（英语：Message queue）是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a>或同一进程的不同<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B">线程</a>间的通信方式，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B2%AF%E5%88%97">贮列</a>用来处理一系列的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5">输入</a>，通常是来自用户。消息队列提供了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%95%B0%E6%AD%A5">异步</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">通信协议</a>，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列</a>中，直到接收者取回它。  来自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">wiki</a>。</p>
<p>同一进程的不同线程间通信使用比较多的就是线程池了，在jdk里面，线程池就是将runnable包装为一个个worker，然后放在队列中，由各种调度方式去调用worker。</p>
<p>而跨进程间通信使用的比较多的就是<a target="_blank" rel="noopener" href="https://kafka.apache.org/">kafka</a>，<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">rabbitmq</a>，<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/">rocketmq</a>，<a target="_blank" rel="noopener" href="https://activemq.apache.org/">activemq</a>等等消息队列中间件。</p>
 <a id="more"></a>

<h2 id="简单的MQ"><a href="#简单的MQ" class="headerlink" title="简单的MQ"></a>简单的MQ</h2><p>现在我们来考虑如果我们想自己手动撸一个mq，该怎么做？首先我们考虑对外提供的接口，无论是<code>rpc</code>还是<code>restfull</code>，由于我们是JAVA攻城狮，我们就提供国内最流行的<code>dubbo</code>服务接口。接口为<code>MySimpleMqServiceApi</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MySimpleMqServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Message message)</span></span>;</span><br><span class="line">    <span class="function">Message <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对外我们仅提供两个方法，一个是发送（push），一个是拉取（poll）</p>
<p>然后定义下<code>Message</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是对外提供服务了，因为我们是最最简单的，相当于站在最高的那个巨人的头顶的最高的头发丝上，所以我们现在完全不考虑内存，网络。也就是说现在的内存是无限的，网络是无限的，CPU是无限的，我们的主机永不crash，哪怕主机放到了黑洞，放在宇宙的边缘，他都可以在微秒级别给你返回,而且我们的用户永远不会给我们错误的数据，每次都是传送给我们最标准的数据。</p>
<p>首先只想要一个人发送消息，一个人拉消息。由于是无限的队列，所以我们就用链表实现一个队列就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleMqService</span> <span class="keyword">implements</span> <span class="title">MySimpleMqServiceApi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; store=<span class="keyword">new</span> LinkedList&lt;Message&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        store.push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(store.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span>   store.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在，我们的最简单的MQ已经完成了。我们对外提供的功能和保障有：</p>
<ul>
<li>你发给我消息，我会给你保存，你放心，我这边的电脑是无敌的，肯定不会出任何问题</li>
<li>消息你一收到，我就直接删除了。</li>
</ul>
<p>上面有啥问题呢？最简单的一个问题就是，大家都放在同一个队列里，不能按照自己想要的队列来进行拉去或者消费。于是咱拍拍脑袋，知道该怎么做了，做个隔离嘛，小意思,修改下api，我们的客户当然是宇宙最美好客户，说我们只要改好，他立马更新代码发版本。于是我们增加了<code>domain</code>信息，让他们自己去定义自己存放在那个域下面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mode.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MySimpleMqServiceApiV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(String domain,Message message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Message <span class="title">poll</span><span class="params">(String domain)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleMqServiceV2</span> <span class="keyword">implements</span> <span class="title">MySimpleMqServiceApiV2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, LinkedList&lt;Message&gt;&gt; mqStore=<span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;Message&gt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String domain, Message message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==mqStore.get(domain))&#123;</span><br><span class="line">            mqStore.put(domain,<span class="keyword">new</span> LinkedList&lt;Message&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        mqStore.get(domain).push(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">poll</span><span class="params">(String domain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  mqStore.get(domain).poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个mq，大家随便造。你说不支持高并发，没关系，将上面的全部整成并发的工具包。</p>
<p>我们现在来看下，我们的假设多虎：</p>
<ul>
<li><p>主机永远不crash。</p>
</li>
<li><p>网络不限永远稳定</p>
</li>
<li><p>cpu，内存资源无限</p>
</li>
<li><p>磁盘？内存都无限了，主机用不crash还要磁盘做啥。</p>
</li>
<li><p>一个消息只会被同一个域下的消费者消费。</p>
</li>
<li><p>客户按照我们的想法来，呵护我们，他们甚至发送的消息都是自动有序的。说用dubbo，绝对不会说他们是sofa-rpc，也不会说他们语言不支持该协议。啥时候升级，他们立马帮你修改业务代码。</p>
<p>…….</p>
</li>
</ul>
<p>那么我们真正面对的问题是啥呢？</p>
<ul>
<li>电脑肯定不是无敌，可能随时crash，内存数据肯定丢失</li>
<li>同一个消息可能被不同的域消费。</li>
<li>客户不想使用<code>dubbo</code>来和我们交互，而且客户不想频繁的升级改代码。</li>
<li>电脑的资源肯定是有限的，但是客户想要的qps是极其吓人的。</li>
<li>…….</li>
</ul>
<p>所以我们现在需要解决的问题如下：</p>
<ul>
<li><p>如何保证数据在随时crash的机器上不丢失。</p>
</li>
<li><p>需要提供有序的队列，至少在单个broker中的有序，保证FIFO</p>
</li>
<li><p>需要多生产者多消费者一起。</p>
</li>
<li><p>需要考虑网络延迟，我们的服务可能突然被防火墙干掉了。</p>
</li>
<li><p>要为客户提供一个客户端，让他们使用起来如丝般柔滑，而且更新只需要他们动动小手指随便敲两下就ok。</p>
</li>
<li><p>需要保证qps。</p>
</li>
<li><p>需要保证大量的数据堆积</p>
<p>….</p>
</li>
</ul>
<h3 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h3><p>首先，我们需要保证的就是数据在随时crash的机器上不丢失，自然而然就是采用分布式集群的方式部署。分布式中的理论<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP</a>.</p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA&action=edit&redlink=1">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86#cite_note-3">3]</a>。）</li>
</ul>
<p>由于消息一般情况下是不会有更新和删除的操作的，所以一致性在是我们最后才考虑的问题。主要是做到高可用和分区容错。</p>
<p>可用性，我们都知道在使用无状态集群的时候，比如rpc的provider方，如果我们采用的是集群，那么如果provider某一台机器挂了，consumer可能会出错（crash时当前的链接断开），后面采用重试或者服务降级的方式是不会造成大面积报错甚至服务宕机的。那么作为消息队列，我们也要自然也想要对broker进行集群部署。</p>
<p>现在我们已经有个集群了，里面部署了我们的程序。但是和上面的provider不一样的地方在于，其实我们更像是一个数据库，而不是逻辑处理的provider。于是，首先按照数据库的来做，自然会想到主从复制的方法保证数据不丢失。于是我们现在的逻辑首先是一台主broker，其他的作为从broker。数据全部走主broker，其他的只是负责在主broker挂掉或者掉线的时候升级为主节点对外提供服务。</p>
<p>这种模式在数据量比较少，吞吐不大的时候是比较好的选择。毕竟虽然机器随时crash，但也不是每分钟一次，感谢运维的小伙伴让我们的服务器运行的比较稳定。</p>
<p>但是我们想要解决的问题不是数据量小的情况。而是想要解决在特定的时候，突然大量的数据涌进来，每秒几万几十万的数据。如果使用数据库这种主从复制的方法，所有的message，都会被写n次，主broker的负载也会急剧上升。所以是不能单纯用主从复制来做的，或者说在某些情况下，比如日志收集等情况下，这种方式其实是不能符合欲求的。</p>
<p>于是可以使用链式复制。其中链式复制可以理解为将broker 变成一个队列类型，大家穿成一串，大家都从自己的上游节点复制。这样就不再是都从主节点复制。但是每台机器上还是保存了所有的数据，如果在大量数据堆积的时候，数据量被放大很多倍。</p>
<p>随着数据量增大，所有数据存放在同一台机器上的成本上升，收益也开始变小。如果我们每台机器上都只有部分数据，合在一起就是所有数据。然后选几台机器互为主从，大家都只保留部分数据的副本，在极端的情况下，也只会有部分的数据无法访问，但是整体式能够对外保证服务的。</p>
<p>这就是分区。将数据分区，和数据库的里面的分库分表在某种意义上类似。</p>
<p>我们可以设置一个注册中心，对外提供broker的地址和端口，还有broker存储的副本数据分布方式。主分区节点和备分区节点的路由信息。</p>
<p>读者会发现，笔者一直在拿数据库和MQ做对比，其实MQ确实是一种比较特殊的数据库。我们现在老考虑下他的特殊性在哪里。</p>
<ul>
<li>不需要符合范式</li>
<li>数据的读取是FIFO</li>
<li>数据的读取方式比较单一，一般只有写入message和读取message，而且一般情况下是顺序读取和写入，也就是上面的FIFO</li>
</ul>
<p>看到顺序写入，在考虑到我们上面的复制和分区，自然就会想到wal日志系统。mq的文件其实也可以看作为在大数据中常常用来保证宕机也不丢数据的wal日志。因为他们本质上有非常类似的作用。</p>
<p>wal日志的作用就是数据进来后，首先会在wal日志里面写入，由于是按照时间顺序，先接收到数据就先写入文件，如果出现处理过程宕机就可以从wal日志中恢复数据。</p>
<p>mq也是顺序写入，在一般情况存储的位置也只和写入时间有关系。</p>
<p>wal的优点在顺序写，顺序写磁盘的速度是几乎接近于内存的读写状态的。</p>
<p>现在，我们mq的主要架构就比较清楚了。首先会有一个注册中心，主要用来保证注册broker的信息，有broker，他们会注册自己的信息到注册中心，然后消息生产方会在注册中心中拿到对应broker的ip地址，消息消费方也会从注册中心拉取broker的地址。当然，还有很多细节没有考虑，如负载均衡、读写分离、数据存储格式等等。</p>
<p>我们看一下rocketmq的是否按照我们的想法来做的，看下彼此的架构的区别。</p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>我们将带着上面的问题来看rocketmq是如何解决这些问题的，然后在看代码的过程中会去考虑为什么它要这么设计。首先，上面的模型目前普遍的称呼为三种，发送方为producer，消费方为consumer，消息存储叫broker。broker这个词是经纪人的意思，是为促成他人交易，充当订约居间人，为委托方提供订约的信息、机会和条件的主体。也就是说，他的主要作用是提供双方合作的一个主体，是不同于proxy会形式producer方的功能，agent会行使消费放的功能。</p>
<p>目前基本上所有的mq架构都是由producer传递消息到broker，broker将消息存储起来，然后由consumer消费。消息存储的domain为topic。</p>
<h4 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h4><p>首先看下<a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/tree/master/docs/cn">官方文档</a></p>
<h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><h6 id="1-消息模型（Message-Model）"><a href="#1-消息模型（Message-Model）" class="headerlink" title="1 消息模型（Message Model）"></a>1 消息模型（Message Model）</h6><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<h6 id="2-消息生产者（Producer）"><a href="#2-消息生产者（Producer）" class="headerlink" title="2 消息生产者（Producer）"></a>2 消息生产者（Producer）</h6><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<h6 id="3-消息消费者（Consumer）"><a href="#3-消息消费者（Consumer）" class="headerlink" title="3 消息消费者（Consumer）"></a>3 消息消费者（Consumer）</h6><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费（pull）、推动式（push）消费。</p>
<h6 id="4-主题（Topic）"><a href="#4-主题（Topic）" class="headerlink" title="4 主题（Topic）"></a>4 主题（Topic）</h6><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<h6 id="5-代理服务器（Broker-Server）"><a href="#5-代理服务器（Broker-Server）" class="headerlink" title="5 代理服务器（Broker Server）"></a>5 代理服务器（Broker Server）</h6><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h6 id="6-名字服务（Name-Server）"><a href="#6-名字服务（Name-Server）" class="headerlink" title="6 名字服务（Name Server）"></a>6 名字服务（Name Server）</h6><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<h6 id="7-拉取式消费（Pull-Consumer）"><a href="#7-拉取式消费（Pull-Consumer）" class="headerlink" title="7 拉取式消费（Pull Consumer）"></a>7 拉取式消费（Pull Consumer）</h6><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<h6 id="8-推动式消费（Push-Consumer）"><a href="#8-推动式消费（Push-Consumer）" class="headerlink" title="8 推动式消费（Push Consumer）"></a>8 推动式消费（Push Consumer）</h6><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<h6 id="9-生产者组（Producer-Group）"><a href="#9-生产者组（Producer-Group）" class="headerlink" title="9 生产者组（Producer Group）"></a>9 生产者组（Producer Group）</h6><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<h6 id="10-消费者组（Consumer-Group）"><a href="#10-消费者组（Consumer-Group）" class="headerlink" title="10 消费者组（Consumer Group）"></a>10 消费者组（Consumer Group）</h6><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<h6 id="11-集群消费（Clustering）"><a href="#11-集群消费（Clustering）" class="headerlink" title="11 集群消费（Clustering）"></a>11 集群消费（Clustering）</h6><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h6 id="12-广播消费（Broadcasting）"><a href="#12-广播消费（Broadcasting）" class="headerlink" title="12 广播消费（Broadcasting）"></a>12 广播消费（Broadcasting）</h6><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h6 id="13-普通顺序消息（Normal-Ordered-Message）"><a href="#13-普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="13 普通顺序消息（Normal Ordered Message）"></a>13 普通顺序消息（Normal Ordered Message）</h6><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<h6 id="14-严格顺序消息（Strictly-Ordered-Message）"><a href="#14-严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="14 严格顺序消息（Strictly Ordered Message）"></a>14 严格顺序消息（Strictly Ordered Message）</h6><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h6 id="15-消息（Message）"><a href="#15-消息（Message）" class="headerlink" title="15 消息（Message）"></a>15 消息（Message）</h6><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h6 id="16-标签（Tag）"><a href="#16-标签（Tag）" class="headerlink" title="16 标签（Tag）"></a>16 标签（Tag）</h6><p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<p>上面是rocketmq支持的功能，Nameserver就是上文中说到的注册中心。这里比较奇怪，其实这些信息可以存放在zk里面。想比于zk，这里面的nameserver是无状态的，每个机器独立部署，互相之间不通信，这么做的好处很明显，就是每个无论挂了那个nameserver，只要有一个活着就可以使用，那么如果出现某些特殊的情况。比如当前的nameserver只能被部分的broker访问，是否会出现集群脑裂？后文我们会考虑下为什么不使用zk来作为注册中心。</p>
<p>然后支持的模式有pull和push，一个是consumer主动拉信息，一个是producer主动将message推送到consumer方。支持广播模式，可以将同一个信息传送到所有的consumer方。</p>
<p>支持tag，为消息设置标示，将同一个topic下的信息进行区分。为consumer方提供了一个group。</p>
<p>为什么设置一个group呢，我们每一个topic下的consumer方订阅到topic就可以了。考虑一个场景就是如果没有group的话，如果我们将消费信息存储在consumer方，也就是consumer自己管理自己的消费信息，减少broker的职能，那么不便于做负载均衡和容错。因为broker本身是不知道自己下面的consumer方的消息的。如果将消费信息存储在broker方，那么需要为每一个consumer都记录下消费的信息，然后判断哪些是在一个集群下的，如何判断是否在一个集群下，如果单单只使用topic的维度，如果有多个集群在同时消费同一个topic，而且他们的处理逻辑不是一致的，也就是属于不同业务线，那么就无法区分目前的consumer是属于那个集群的。如果我们使用同一个group来消费不同topic，如果group的信息的记录维度是topic，即每个topic下都会记录对于的consumer group，那么我个人觉得也是可以正常使用的。如果consumergroup的信息和topic是分开或者不是属于topic的下级分类，那么肯定是会出问题的。这个问题可以留到后面看代码的时候，知晓consumergroup的维度的时候在来看。</p>
<p>现在留下的问题（todo）：</p>
<ul>
<li>为什么不实用zk作为注册中心</li>
<li>如果出现部分注册中心只能被部分消费者和生产者访问，是否会出现脑裂的情况，或者消息永远不会被访问</li>
<li>consumer group和topic的关系</li>
</ul>
<h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_architecture_1.png"></p>
<p>RocketMQ架构上主要分为四部分，如上图所示:</p>
<ul>
<li><p>Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
</li>
<li><p>Consumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p>
</li>
<li><p>NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。 </p>
</li>
<li><p>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p>
<ol>
<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</li>
<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>
<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li>
</ol>
</li>
</ul>
<h5 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h5><p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_architecture_2.png"></p>
<h5 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h5><ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</p>
</li>
</ul>
<p>结合部署架构图，描述集群工作流程：</p>
<ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<p>从部署来看，nameserver属于无状态，对外提供注册topic信息。producer在nameserver中获取topic的信息，且随机选择nameserver，建立长链接，定期获取topic的路由信息。并且向提供topic的master和slave建立长链接，定时发送心跳。如果出现。master的突然挂掉，没有自动从新选主，也就是说不会存在脑裂的情况。因为如果部分producer只能和主节点通信，nameserver并没有提供重新选出一个slave节点的能力，哪怕slave的id为1这种特殊的参与消息读负载的slave，也不会升级为master。如果部署的为多个master和多个slave的结构的话，可以理解为当前的消息会被发送到所有的master-slave的小集群中，而整个rocketmq的集群由多个小的master-slave集群组成。如果当前某一个master集群中的master挂掉，则可能会丢失部分数据（master中的消息没有被同步到slave中）。可以看到，rocketmq可以说通过一种极为特殊和简单暴力的方式保证了高可用和不会脑裂。因为没有主从切换，则不会出现小集群中master和slave数据不一致的问题，只会出现slave的数据不完全的问题。但是留下一个问题，如果是分区有序的消息该如何解决。可以解决上面的问题，没有主从切换，nameserver仅仅做心跳检查和存储topic的信息，所以zk是过重的存在。但是可能存在部分消息丢失（不能被消费）的问题，但是不会出现脑裂的情况，因为没有master切换的情况出现，一个master出问题，可以将消息发送到其他的master中。</p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><h6 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h6><p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_1.png" alt="架构设计"></p>
<p>消息存储是RocketMQ中最为复杂和最为重要的一部分，本节将分别从RocketMQ的消息存储整体架构、PageCache与Mmap内存映射以及RocketMQ中两种不同的刷盘方式三方面来分别展开叙述。</p>
<h6 id="1-1-消息存储整体架构"><a href="#1-1-消息存储整体架构" class="headerlink" title="1.1 消息存储整体架构"></a>1.1 消息存储整体架构</h6><p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<p>(1) CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
<p>(2) ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p>
<p>(3) IndexFile：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p>
<p>在上面的RocketMQ的消息存储整体架构图中可以看出，RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<h6 id="1-2-页缓存与内存映射"><a href="#1-2-页缓存与内存映射" class="headerlink" title="1.2 页缓存与内存映射"></a>1.2 页缓存与内存映射</h6><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<p>在消息存储的架构中图上我们可以看出，rocketmq的存储并不是按照topic来的，也就是所有的消息都会存储在同一个文件下，这个文件为CommitLog。这个文件最大为1G，为什么为1G呢？然后就是为了加快访问速度，将consumer的消费信息存储在了ConsumeQueue中。ConsumeQueue中存储的数据分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode。由于字节的长度不唱过4字节，也就是说最长的单个消息不应该超过4GB，当然，肯定是满足我们的需求的。一般情况下，大的文件一般使用文件存储系统。</p>
<p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_datafile.png"></p>
<p>上文中的unit-test就是定义的topic，全部使用默认配置，则会有8个（0-7）个queueid。按照架构设计文档，我们主要是从consumerqueue中获取到当前的消费信息，然后去对应的commitlog中获取消息。而consumerqueue中存储的数据只是一些源数据，也就是commitlog的物理偏移量，消息长度等信息。所以，我们是顺序写入commitlog文件，但是在某种意义上来说是随机读取commitlog文件的（毕竟拉消息不会是随机拉取，也是随机读取）。上文也提到，在顺序读或者写的时候，磁盘的数据是接近于内存的。是因为部分内存会被当作pagecache，然后异步将这部分数据刷入磁盘。如果在刷盘的时候机器crash掉了，那么内存中的数据肯定是丢失的，只有在机器本身carsh或者说服务器断电等情况下，该部分数据会丢失，如果只是进程挂点，则不会。内存映射就比较好理解一些，其实就是跳过了用户态和内核态，减少一次数据拷贝。一起来看，就可以理解为，首先会有pagecache将数据从磁盘映射到内存，然后由mmap映射到pagecache，而不需要将数据copy到内核态，在映射到pagecache。</p>
<p>现在来看为什么commitlog的大小需要设置为1GB，主要也是由于FileChannel的map方法中设置了大小不能超过2147483647。也就是2GB左右的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode var1, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;Mode is null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative position&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative size&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position + size &lt; <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Position + size overflow&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">2147483647L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Size exceeds Integer.MAX_VALUE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h4><p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_2.png"></p>
<p>(1) 同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</p>
<p>(2) 异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>RocketMQ消息队列集群主要包括NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p>
<p>(1) Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</p>
<p>(2) 消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</p>
<p>(3) 消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</p>
<p>(4) 消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</p>
<p>从上面1）~3）中可以看出在消息生产者, Broker和NameServer之间都会发生通信（这里只说了MQ的部分通信），因此如何设计一个良好的网络通信模块在MQ中至关重要，它将决定RocketMQ集群整体的消息传输能力与最终的性能。</p>
<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>
<h4 id="Remoting通信类结构"><a href="#Remoting通信类结构" class="headerlink" title="Remoting通信类结构"></a>Remoting通信类结构</h4><p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_3.png"></p>
<h4 id="协议设计与编解码"><a href="#协议设计与编解码" class="headerlink" title="协议设计与编解码"></a>协议设计与编解码</h4><p>在Client和Server之间完成一次消息发送时，需要对发送的消息进行一个协议约定，因此就有必要自定义RocketMQ的消息协议。同时，为了高效地在网络中传输消息和对收到的消息读取，就需要对消息进行编解码。在RocketMQ中，RemotingCommand这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request说明</th>
<th>Response说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_design_4.png" alt="img"></p>
<p>可见传输内容主要可以分为以下4部分：</p>
<p>(1) 消息长度：总长度，四个字节存储，占用一个int类型；</p>
<p>(2) 序列化类型&amp;消息头长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；</p>
<p>(3) 消息头数据：经过序列化后的消息头数据；</p>
<p>(4) 消息主体数据：消息主体的二进制字节数据内容；</p>
<h4 id="消息的通信方式和流程"><a href="#消息的通信方式和流程" class="headerlink" title="消息的通信方式和流程"></a>消息的通信方式和流程</h4><p>在RocketMQ消息队列中支持通信的方式主要有同步(sync)、异步(async)、单向(oneway) 三种。其中“单向”通信模式相对简单，一般用在发送心跳包场景下，无需关注其Response。这里，主要介绍RocketMQ的异步通信流程。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_5.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_5.png" alt="img"></a></p>
<h4 id="Reactor多线程设计"><a href="#Reactor多线程设计" class="headerlink" title="Reactor多线程设计"></a>Reactor多线程设计</h4><p>RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循了Reactor多线程模型，同时又在这之上做了一些扩展和优化。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_6.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_6.png" alt="img"></a></p>
<p>上面的框图中可以大致了解RocketMQ中NettyRemotingServer的Reactor 多线程模型。一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接，创建SocketChannel，并注册到selector上。RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置）,然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），在真正执行业务逻辑之前需要进行SSL验证、编解码、空闲检查、网络连接管理，这些工作交给defaultEventExecutorGroup（即为上面的“M1”，源码中默认设置为8）去做。而处理业务操作放在业务线程池中执行，根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务processor处理线程池</td>
</tr>
</tbody></table>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer端订阅消息采用分离存储的机制来实现的，Consumer端订阅消息是需要通过ConsumeQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也是还绕不开其存储结构。其ConsumeQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_7.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_7.png" alt="img"></a></p>
<p>主要支持如下2种的过滤方式 (1) Tag过滤方式：Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p>
<p>(2) SQL92的过滤方式：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h4 id="Producer的负载均衡"><a href="#Producer的负载均衡" class="headerlink" title="Producer的负载均衡"></a>Producer的负载均衡</h4><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h4 id="Consumer的负载均衡"><a href="#Consumer的负载均衡" class="headerlink" title="Consumer的负载均衡"></a>Consumer的负载均衡</h4><p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p>
<p>1、Consumer端的心跳包发送</p>
<p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p>
<p>2、Consumer端实现负载均衡的核心类—RebalanceImpl</p>
<p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。这里，rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
<p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p>
<p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求（Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</p>
<p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_8.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_8.png" alt="img"></a></p>
<p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_9.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_9.png" alt="img"></a></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
</ul>
<p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空，这样子也就回答了上一篇中最后的那道思考题了。</p>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p>
<h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_10.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_10.png" alt="img"></a></p>
<h4 id="RocketMQ事务消息流程概要"><a href="#RocketMQ事务消息流程概要" class="headerlink" title="RocketMQ事务消息流程概要"></a>RocketMQ事务消息流程概要</h4><p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1.事务消息发送及提交：</p>
<p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2.补偿流程：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="RocketMQ事务消息设计"><a href="#RocketMQ事务消息设计" class="headerlink" title="RocketMQ事务消息设计"></a>RocketMQ事务消息设计</h4><p>1.事务消息在一阶段对用户不可见</p>
<p>在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
<p>在RocketMQ中，消息在服务端的存储结构如下，每条消息都会有对应的索引信息，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容，其流程如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_11.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_11.png" alt="img"></a></p>
<p>RocketMQ的具体实现策略是：写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。</p>
<p>2.Commit和Rollback操作以及Op消息的引入</p>
<p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</p>
<p>3.Op消息的存储和对应关系</p>
<p>RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，这样通过Op消息能索引到Half消息进行后续的回查操作。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_12.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_12.png" alt="img"></a></p>
<p>4.Half消息的索引构建</p>
<p>在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p>
<p>5.如何处理二阶段失败的消息？</p>
<p>如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“回查”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h3 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h3><p>RocketMQ支持按照下面两种维度（“按照Message Id查询消息”、“按照Message Key查询消息”）进行消息查询。</p>
<h4 id="按照MessageId查询消息"><a href="#按照MessageId查询消息" class="headerlink" title="按照MessageId查询消息"></a>按照MessageId查询消息</h4><p>RocketMQ中的MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口），消息Commit Log offset。“按照MessageId查询消息”在RocketMQ中具体做法是：Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p>
<h4 id="按照Message-Key查询消息"><a href="#按照Message-Key查询消息" class="headerlink" title="按照Message Key查询消息"></a>按照Message Key查询消息</h4><p>“按照Message Key查询消息”，主要是基于RocketMQ的IndexFile索引文件来实现的。RocketMQ的索引文件逻辑结构，类似JDK中HashMap的实现。索引文件的具体结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/master/docs/cn/image/rocketmq_design_13.png"><img src="https://github.com/apache/rocketmq/raw/master/docs/cn/image/rocketmq_design_13.png" alt="img"></a></p>
<p>IndexFile索引文件为用户提供通过“按照Message Key查询消息”的消息索引查询服务，IndexFile文件的存储位置是：$HOME\store\index${fileName}，文件名fileName是以创建时的时间戳命名的，文件大小是固定的，等于40+500W<em>4+2000W</em>20= 420000040个字节大小。如果消息的properties中设置了UNIQ_KEY这个属性，就用 topic + “#” + UNIQ_KEY的value作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。</p>
<p>其中的索引数据包含了Key Hash/CommitLog Offset/Timestamp/NextIndex offset 这四个字段，一共20 Byte。NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了。Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间。整个Index File的结构如图，40 Byte 的Header用于保存一些总的统计信息，4<em>500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20</em>2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。</p>
<p>“按照Message Key查询消息”的方式，RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</p>
<p>上面的文档基本上都是具体如何实现的文档了，在看下相应源代码的时候可以回头再来看。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>如果不使用直接看源码会比较累，而且rocketmq里面的方法常常是大的嵌套，看起来很累。。所以看的过程中带着一些问题去了解下</p>
<ul>
<li>group和topic的关系</li>
<li>是否支持内存模式</li>
<li>主从复制是否会导致丢数据</li>
<li>顺序消息是如何保证顺序</li>
<li>死信队列中的消息是否会自动删除</li>
<li>消息没有被消费时候会自动过期</li>
<li>事务消息是如何保存</li>
</ul>
<h6 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h6><ul>
<li><p>nameserver 由于nameserver 主要是用于保存topic的对应信息。</p>
</li>
<li><p>broker</p>
<p>​    broker的启动比较复杂，需要从历史数据拉取数据，还需要向nameserver发送信息。源码主要处于<code>org.apache.rocketmq.broker.BrokerStartup</code>。</p>
<p>整个过程代码比较多和复杂，这里简单说下就可以。主要步骤：</p>
<ol>
<li>创建BrokerController</li>
<li>初始化BokerController中各种线程池、messagestore、netty、producer管理、broker状态机等</li>
<li>拉取历史数据</li>
</ol>
<p>第二步中，BokerController 中的主要线程池如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExecutorService sendMessageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService pullMessageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService replyMessageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService queryMessageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService adminBrokerExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService clientManageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService heartbeatExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService consumerManageExecutor;</span><br><span class="line"> <span class="keyword">private</span> ExecutorService endTransactionExecutor;</span><br></pre></td></tr></table></figure>

<p>这些线程池的命名就可以看出不同线程池的作用，我们先按下不表，等后续用到的时候在详细看每个线程池在消息发送和接收处理过程中的作用。</p>
<p>broker的状态机(BrokerStats)主要记录put和get数据的多少</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgPutTotalYesterdayMorning;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgPutTotalTodayMorning;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgGetTotalYesterdayMorning;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgGetTotalTodayMorning;</span><br></pre></td></tr></table></figure>

<p>主要来看**<em><code>messagestore</code>**</em>。码如其名，他的作用主要是消息存储相关的，结合上文，我们知道rocketmq的消息主要是存放在commitlog里，而consumerqueue主要是保存对应topic下的消息offset。<code>DefaultMessageStore</code>是message的默认实现。里面的成员变量比较多，下面说一些和主要逻辑比较重要的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储消息的地方 </span></span><br><span class="line">CommitLog commitLog;</span><br><span class="line"><span class="comment">// 消费队列，按照topic进行topic隔离，然后根据queueid进行相同topic下消息队列分区</span></span><br><span class="line">ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;</span><br><span class="line"><span class="comment">// 持久化consumerqueue的数据到磁盘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;</span><br><span class="line"><span class="comment">// 清理日志文件和消费者队列文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;</span><br><span class="line"><span class="comment">//更新ConsumeQueue中消息偏移</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;</span><br><span class="line"><span class="comment">//高可用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;</span><br><span class="line"><span class="comment">//延迟消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;</span><br><span class="line"><span class="comment">//暂时存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;</span><br></pre></td></tr></table></figure>

<p>上面不是全部的对象成员变量。但是和message的存储是有直接关系的。haService 是基于DLegerCommitLog来做的，暂时也不涉及。主要是看些producer的消息在已经被解析的情况下，是如何存储到commitlog中，然后是通过何种方式被放到consumerqueue中的。</p>
<p><img src="/2021/10/08/RocketMQ%E5%AD%A6%E4%B9%A0/rocketmq_save_message_1.png" alt="rocketmq_save_message_1"></p>
<p>上图是使用同步刷盘的方式。虽然是同步刷盘，但是rocketmq里面，无论是写入文件还是同步数据，都是使用的异步方式，只是同步模式下，需要等待刷盘或者slave的结果：</p>
<p>刷盘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PutMessageStatus&gt; <span class="title">submitFlushRequest</span><span class="params">(AppendMessageResult result, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">        <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes(),</span><br><span class="line">                    <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">            <span class="keyword">return</span> request.future();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slave同步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PutMessageStatus&gt; <span class="title">submitReplicaRequest</span><span class="params">(AppendMessageResult result, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SYNC_MASTER == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        HAService service = <span class="keyword">this</span>.defaultMessageStore.getHaService();</span><br><span class="line">        <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (service.isSlaveOK(result.getWroteBytes() + result.getWroteOffset())) &#123;</span><br><span class="line">                GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes(),</span><br><span class="line">                        <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">                service.putRequest(request);</span><br><span class="line">                service.getWaitNotifyObject().wakeupAll();</span><br><span class="line">                <span class="keyword">return</span> request.future();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.SLAVE_NOT_AVAILABLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>slave最后会发送到HAService中。上图中的代码可以看到，发送的数据只是offset，然后发送到HAService的GroupTransferService中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">            <span class="keyword">long</span> waitUntilWhen = HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now()</span><br><span class="line">                    + HAService.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout();</span><br><span class="line">            <span class="keyword">while</span> (!transferOK &amp;&amp; HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() &lt; waitUntilWhen) &#123;</span><br><span class="line">                <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">                transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;transfer messsage to slave timeout, &quot;</span> + req.getNextOffset());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            req.wakeupCustomer(transferOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_SLAVE_TIMEOUT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.requestsRead = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doWaitTransfer 这个方法中，其实并没有传送数据，而是查看当前发送给slave的最大offset有没有查过当前消息的offset。也就是说，如果在传送的过程中slave不可达，回每个1s重试看是否已经被slave收到，或者超时退出。所以其实发送消息进行同步的时候，还是依赖于slave的同步机制。为了不让落后太多message的slave来进行这个操作，submitReplicaRequest会判断是否是合适的slave，判断的方式就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//haSlaveFallbehindMax = 1024 * 1024 * 256; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSlaveOK</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> masterPutWhere)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.connectionCount.get() &gt; <span class="number">0</span>;</span><br><span class="line">    result =</span><br><span class="line">        result</span><br><span class="line">            &amp;&amp; ((masterPutWhere - <span class="keyword">this</span>.push2SlaveMaxOffset.get()) &lt; <span class="keyword">this</span>.defaultMessageStore</span><br><span class="line">            .getMessageStoreConfig().getHaSlaveFallbehindMax());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果说当前的slave处于存活状态。在<code>DefaultMessageStore</code>创建的时候回创建一个<code>HAService</code>,而<code>HAService</code>中回创建一个accept线程，来不断轮训端口（haListenPort）获取到的链接，如果有链接进来，则说明有slave链接到当前master，后续会创建<code>HAConnection</code>,该connection中，slave会上报自己的offset，该部分主要在<code>ReadSocketService.processReadEvent</code>中处理，然后会拉去数据，该部分在<code>WriteSocketService.transferData</code>中处理，这里不在赘述，总之，rocketmq中的消息复制都是异步的进行的，同步复制的时候也只是判断offset是否超过记录的当前message的offset的位置。这里需要注意，在注册到nameserver的过程中，master-salve的判断方式是使用的brokerName，也就是相同的brokername 表示属于同一个主从集群。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RouteInfoManager.registerBroker				</span></span><br><span class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                    <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                        <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                            result.setMasterAddr(masterAddr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>综上所诉： 如果当前的master已经有一个slave，且该slave的同步数据是一直同步的（commitlog的offset少于256M），那么肯定可以同步复制数据，如果新增salve也是可以同步的，因为记录offset的最大值是HAService的变量。只要有一个slave 能够满足就可以，但是如果在同步的过程中原来正常同步的slave挂点，新slave没有追上，就会报错。但是都是异步写数据，会在占用网络宽带，所以不会影响当前集群性能。</p>
<p>结合上面的代码和解释，已经了解到message是如何被复制到从节点和刷盘是如何同步进行的。但是上文也说到，还涉及到一部分，就是关于consumerqueue，因为默认情况下，每个消息队列都有8个consumerqueue，那么消息是如何判断发送到哪个consumerqueue中的。broker是如何处理这些数据的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-------- 发送的message ------</span><br><span class="line">    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;demo_2&quot;</span>,<span class="string">&quot;TagA&quot;</span>,<span class="string">&quot;OrderID188&quot;</span>, </span><br><span class="line">                              <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">-------- 写入到文件中的message ------</span><br><span class="line">brokerName=<span class="keyword">null</span>, </span><br><span class="line">queueId=<span class="number">3</span>,</span><br><span class="line">storeSize=<span class="number">0</span>, </span><br><span class="line">queueOffset=<span class="number">0</span>, </span><br><span class="line">sysFlag=<span class="number">0</span>,</span><br><span class="line">bornTimestamp=<span class="number">1633955311066</span>,</span><br><span class="line">bornHost=/<span class="number">192.168</span><span class="number">.2</span><span class="number">.95</span>:<span class="number">57719</span>, </span><br><span class="line">storeTimestamp=<span class="number">1633955311070</span>, </span><br><span class="line">storeHost=/<span class="number">192.168</span><span class="number">.2</span><span class="number">.95</span>:<span class="number">10910</span>, </span><br><span class="line">msgId=<span class="keyword">null</span>, commitLogOffset=<span class="number">0</span>,</span><br><span class="line">bodyCRC=<span class="number">198614610</span>, </span><br><span class="line">reconsumeTimes=<span class="number">0</span>, </span><br><span class="line">preparedTransactionOffset=<span class="number">0</span>, </span><br><span class="line">topic=<span class="string">&#x27;demo_2&#x27;</span>, </span><br><span class="line">flag=<span class="number">0</span>, </span><br><span class="line">properties=</span><br><span class="line">KEYS=OrderID188, </span><br><span class="line">UNIQ_KEY=7F0000015F1818B4AAC237E455DA0001, </span><br><span class="line">CLUSTER=hello, </span><br><span class="line">WAIT=<span class="keyword">true</span>, </span><br><span class="line">TAGS=TagA&#125;, </span><br><span class="line">body=[<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">119</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>], </span><br><span class="line">transactionId=<span class="string">&#x27;null&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对比上面的消息原始值和写入日志中的数据，可以看到，写入commitlog文件中的数据多了，queueid等附属信息。接下来主要是看这些数据是如何生成的和处理的，中间会包含顺序消息和事务消息的处理。</p>
<p>producer方发送消息,普通消息（DefaultMQProducerImpl）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-DefaultMQProducerImpl.sendKernelImpl</span><br><span class="line">--TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">--MessageQueue mqSelected = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>tryToFindTopicPublishInfo 会首先在本地查看topic的路由信息，如果没有找到就会去nameserver拉取。<code>DefaultMQProducerImpl</code>中的<code>topicPublishInfoTable</code>,而且<code>MQClientInstance</code>中，有个线程会每隔一段时间（默认30s，pollNameServerInterval）进行更新数据。</li>
<li>selectOneMessageQueue 选择一个队列，也可以在producer中实现selector，由于文件都是顺序写的，所以如果是同一个线程写入broker的同一个队列中，是可以保证分区有序的。分区有序是针对一个broker下的queue里面的消息是有序的。如果在producer中，某个broker突然挂掉，会造成原来的分区被分配到其他的队列中，这样consumer的队列就无法保证有序。</li>
</ul>
<h2 id="topic的管理"><a href="#topic的管理" class="headerlink" title="topic的管理"></a>topic的管理</h2><p>创建topic，如果制定为集群创建，那么对应的topic会创建到broker里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; masterSet =</span><br><span class="line">                CommandUtil.fetchMasterAddrByClusterName(defaultMQAdminExt, clusterName);</span><br><span class="line">            <span class="keyword">for</span> (String addr : masterSet) &#123;</span><br><span class="line">                defaultMQAdminExt.createAndUpdateTopicConfig(addr, topicConfig);</span><br><span class="line">                System.out.printf(<span class="string">&quot;create topic to %s success.%n&quot;</span>, addr);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<p>核心代码如上，是循环的方式给集群中master创建topic，如果没有一个broker没有创建成功，则会直接退出。如果创建topic完成后，新增加的broker也不会有该信息。sofamq会有该topic信息。</p>
<p>broker 收到该topic信息后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line">topicConfig.setReadQueueNums(requestHeader.getReadQueueNums());</span><br><span class="line">topicConfig.setWriteQueueNums(requestHeader.getWriteQueueNums());</span><br><span class="line">topicConfig.setTopicFilterType(requestHeader.getTopicFilterTypeEnum());</span><br><span class="line">topicConfig.setPerm(requestHeader.getPerm());</span><br><span class="line">topicConfig.setTopicSysFlag(requestHeader.getTopicSysFlag() == <span class="keyword">null</span> ? <span class="number">0</span> :          requestHeader.getTopicSysFlag());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>首先更新本地的topic信息，主要是将topic.json 文件更新，将现有数据刷新到磁盘中</li>
<li>出发一次<code>doRegisterBrokerAll</code>,也就是注册到<code>nameserver</code></li>
</ol>
<p>这个时候，对应的topic已经在当前broker中生成，其中按照默认配置，创建了8个写队列，8个读队列。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;demo_4&quot;:&#123;</span><br><span class="line">   &quot;order&quot;:false, //是否顺序写</span><br><span class="line">   &quot;perm&quot;:6, // 读写权限</span><br><span class="line">   &quot;readQueueNums&quot;:8, // 读队列</span><br><span class="line">   &quot;topicFilterType&quot;:&quot;SINGLE_TAG&quot;, // 过滤类型</span><br><span class="line">   &quot;topicName&quot;:&quot;demo_4&quot;, //名字</span><br><span class="line">   &quot;topicSysFlag&quot;:0, //</span><br><span class="line">   &quot;writeQueueNums&quot;:8 //写队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节点扩容： 新增加的broker 如果需要订阅已经创建的topic，则需要重新掉用updatetopic方法。可以针对cluster 集群更新，也可以通过指定broker 更新</p>
<ul>
<li><p>writeQueueNums  作为写消息分区。由创建的时候指定，创建完成后再nameserver存储起来。在producer和consumer进行解析。MQClientInstance#topicRouteData2TopicPublishInfo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">    MessageQueue mq &#x3D; new MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">    info.getMessageQueueList().add(mq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据写队列大小创建messagequeue。        </p>
</li>
<li><p>readQueueNums 同样，首先从nameserver中拉去路由信息，然后转换。MQClientInstance#topicRouteData2TopicSubscribeInfo</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static Set&lt;MessageQueue&gt; topicRouteData2TopicSubscribeInfo(final String topic, final TopicRouteData route) &#123;</span><br><span class="line">    Set&lt;MessageQueue&gt; mqList &#x3D; new HashSet&lt;MessageQueue&gt;();</span><br><span class="line">    List&lt;QueueData&gt; qds &#x3D; route.getQueueDatas();</span><br><span class="line">    for (QueueData qd : qds) &#123;</span><br><span class="line">        if (PermName.isReadable(qd.getPerm())) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; qd.getReadQueueNums(); i++) &#123;</span><br><span class="line">                MessageQueue mq &#x3D; new MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                mqList.add(mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mqList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由此可见，如果说writequeue大于readqueue，那么写入的部分分区中，consumer是不能获取到数据的。反过来，如果说读分区大于写分区，那么在部分的consumer也是没有消费数据的。因为在messagequeue的生成中，没有针对二者做取余操作。</p>
<p>看源码可以得出结论就是：</p>
<p>producer方看来，数据分区是brokersize * writequeuenum的，然后根据算法的到当前的message放入哪个queueid，这个queueid是启动的时候随机一个值后递增来获取的，而且每个线程不一样，因为是该值是放在threadlocal中的。在broker看来，自己管理的queue分区就是writequeuenum个。发送消息的是会在producer中默认轮询messagequeuelist中每一个messagequeue。然后将对应的messagequeue中的信息获取出来如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String topic;</span><br><span class="line"><span class="keyword">private</span> String brokerName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> queueId;</span><br></pre></td></tr></table></figure>

<p>主要包括由brokername，和queueid。然后对brokername对应的broker进行数据发送。发送到broker端以后，根据queueid，将对应的offset放入到consumerqueue下面的对应文件中。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/24/%E6%BA%90%E4%BB%A3%E7%A0%81/netty/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%87%E6%8D%A2%E5%87%86%E5%A4%87/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84MQ"><span class="nav-number">1.1.</span> <span class="nav-text">简单的MQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E7%AB%A0"><span class="nav-number">1.1.1.</span> <span class="nav-text">序章</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ"><span class="nav-number">1.2.</span> <span class="nav-text">RocketMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">官方文档</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-number">1.2.0.1.1.</span> <span class="nav-text">名词解释</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%EF%BC%88Message-Model%EF%BC%89"><span class="nav-number">1.2.0.1.1.1.</span> <span class="nav-text">1 消息模型（Message Model）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%88Producer%EF%BC%89"><span class="nav-number">1.2.0.1.1.2.</span> <span class="nav-text">2 消息生产者（Producer）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%88Consumer%EF%BC%89"><span class="nav-number">1.2.0.1.1.3.</span> <span class="nav-text">3 消息消费者（Consumer）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-%E4%B8%BB%E9%A2%98%EF%BC%88Topic%EF%BC%89"><span class="nav-number">1.2.0.1.1.4.</span> <span class="nav-text">4 主题（Topic）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Broker-Server%EF%BC%89"><span class="nav-number">1.2.0.1.1.5.</span> <span class="nav-text">5 代理服务器（Broker Server）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-%E5%90%8D%E5%AD%97%E6%9C%8D%E5%8A%A1%EF%BC%88Name-Server%EF%BC%89"><span class="nav-number">1.2.0.1.1.6.</span> <span class="nav-text">6 名字服务（Name Server）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-%E6%8B%89%E5%8F%96%E5%BC%8F%E6%B6%88%E8%B4%B9%EF%BC%88Pull-Consumer%EF%BC%89"><span class="nav-number">1.2.0.1.1.7.</span> <span class="nav-text">7 拉取式消费（Pull Consumer）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#8-%E6%8E%A8%E5%8A%A8%E5%BC%8F%E6%B6%88%E8%B4%B9%EF%BC%88Push-Consumer%EF%BC%89"><span class="nav-number">1.2.0.1.1.8.</span> <span class="nav-text">8 推动式消费（Push Consumer）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#9-%E7%94%9F%E4%BA%A7%E8%80%85%E7%BB%84%EF%BC%88Producer-Group%EF%BC%89"><span class="nav-number">1.2.0.1.1.9.</span> <span class="nav-text">9 生产者组（Producer Group）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%EF%BC%88Consumer-Group%EF%BC%89"><span class="nav-number">1.2.0.1.1.10.</span> <span class="nav-text">10 消费者组（Consumer Group）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%EF%BC%88Clustering%EF%BC%89"><span class="nav-number">1.2.0.1.1.11.</span> <span class="nav-text">11 集群消费（Clustering）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#12-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%EF%BC%88Broadcasting%EF%BC%89"><span class="nav-number">1.2.0.1.1.12.</span> <span class="nav-text">12 广播消费（Broadcasting）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#13-%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%EF%BC%88Normal-Ordered-Message%EF%BC%89"><span class="nav-number">1.2.0.1.1.13.</span> <span class="nav-text">13 普通顺序消息（Normal Ordered Message）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#14-%E4%B8%A5%E6%A0%BC%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%EF%BC%88Strictly-Ordered-Message%EF%BC%89"><span class="nav-number">1.2.0.1.1.14.</span> <span class="nav-text">14 严格顺序消息（Strictly Ordered Message）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#15-%E6%B6%88%E6%81%AF%EF%BC%88Message%EF%BC%89"><span class="nav-number">1.2.0.1.1.15.</span> <span class="nav-text">15 消息（Message）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#16-%E6%A0%87%E7%AD%BE%EF%BC%88Tag%EF%BC%89"><span class="nav-number">1.2.0.1.1.16.</span> <span class="nav-text">16 标签（Tag）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.0.1.2.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.0.1.3.</span> <span class="nav-text">部署架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RocketMQ-%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.0.1.4.</span> <span class="nav-text">RocketMQ 网络部署特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">设计</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="nav-number">1.2.0.2.0.1.</span> <span class="nav-text">消息存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-1-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.0.2.0.2.</span> <span class="nav-text">1.1 消息存储整体架构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-2-%E9%A1%B5%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">1.2.0.2.0.3.</span> <span class="nav-text">1.2 页缓存与内存映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">消息刷盘</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.1.</span> <span class="nav-text">通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Remoting%E9%80%9A%E4%BF%A1%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Remoting通信类结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%BC%96%E8%A7%A3%E7%A0%81"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">协议设计与编解码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%92%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">消息的通信方式和流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">Reactor多线程设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">消息过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.2.3.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Producer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Producer的负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">Consumer的负载均衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.4.</span> <span class="nav-text">事务消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A6%81"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">RocketMQ事务消息流程概要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">RocketMQ事务消息设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.2.5.</span> <span class="nav-text">消息查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7MessageId%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">按照MessageId查询消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E7%85%A7Message-Key%E6%9F%A5%E8%AF%A2%E6%B6%88%E6%81%AF"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">按照Message Key查询消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81"><span class="nav-number">1.2.6.</span> <span class="nav-text">源码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Broker"><span class="nav-number">1.2.6.0.0.1.</span> <span class="nav-text">Broker</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#topic%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">topic的管理</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Keanu Lee</p>
  <div class="site-description" itemprop="description">千里之行，始于足下</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keanu Lee</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
